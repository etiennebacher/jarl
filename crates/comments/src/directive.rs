#[derive(Debug, PartialEq)]
pub enum Directive {
    Lint(LintDirective),
}

#[derive(Debug, PartialEq)]
pub struct DirectiveError {
    pub message: String,
}

impl DirectiveError {
    fn new(message: impl Into<String>) -> Self {
        Self { message: message.into() }
    }
}

#[derive(Debug, PartialEq)]
pub enum LintDirective {
    /// Skip all lints for the next node
    Skip,
    /// Skip specific lints for the next node, e.g. "# nolint: any_is_na, coalesce"
    SkipRules(Vec<String>),
    /// Skip an entire file
    SkipFile,
}

/// Parse a comment directive
///
/// These can take the form:
///
/// ```text
/// # nolint
/// # nolint: rule1, rule2
/// ```
///
/// Note that directives are applied to the node they are attached to.
///
/// `text` should be single line but we don't check for this. A potential usage
/// of this function is to iterate over a document line by line to scan for a
/// directive.
///
/// Returns:
/// - `Ok(Some(directive))` - A valid directive was found
/// - `Ok(None)` - Not a directive (just a regular comment)
/// - `Err(error)` - An invalid directive with an error message
pub fn parse_comment_directive(text: &str) -> Result<Option<Directive>, DirectiveError> {
    // Only allow single # followed by space
    let text = text.trim_start();
    if !text.starts_with("# ") {
        return Ok(None);
    }

    let text = &text[2..]; // Skip "# "

    // Handle "nolint" specially to allow both "# nolint" and "# nolint: rules"
    if let Some(stripped) = text.strip_prefix("nolint") {
        let rest = stripped.trim_start();
        if rest.is_empty() {
            // "# nolint" with nothing after -> skip all
            return Ok(Some(Directive::Lint(LintDirective::Skip)));
        } else if let Some(after_colon) = rest.strip_prefix(':') {
            let after_colon = after_colon.trim();
            if after_colon.is_empty() {
                // "# nolint:" with empty rules -> error
                return Err(DirectiveError::new(
                    "Use '# nolint' to skip all rules, or '# nolint: rule_name' to skip specific rules",
                ));
            }
            // "# nolint: rules"
            return parse_lint_directive(after_colon);
        } else {
            // "# nolint" followed by something that's not a colon -> invalid
            return Ok(None);
        }
    }

    // For other directives, require the colon
    let (category, _text) = match text.split_once(':') {
        Some(parts) => parts,
        None => return Ok(None),
    };

    match category {
        _ => Ok(None),
    }
}

// https://github.com/posit-dev/air/issues/219
// Should be called only on the first line in a block of comments.
pub fn parse_special_skip_file(text: &str) -> Option<Directive> {
    // Only allow single # followed by space
    let text = text.trim_start();
    if !text.starts_with("# ") {
        return None;
    }

    let text = &text[2..]; // Skip "# "

    // Convention used in the R community (Roxygen, Rcpp, etc)
    if text.starts_with("Generated by") {
        return Some(Directive::Lint(LintDirective::SkipFile));
    }

    None
}

#[inline]
fn parse_lint_directive(text: &str) -> Result<Option<Directive>, DirectiveError> {
    // Parse comma-separated rule names, e.g. "any_is_na, coalesce"
    let rules: Vec<String> = text
        .split(',')
        .map(|s| s.trim().trim_end_matches("_linter").to_string())
        .filter(|s| !s.is_empty())
        .collect();

    if rules.is_empty() {
        // This shouldn't happen as we check for empty text before calling this
        Err(DirectiveError::new(
            "Use '# nolint' to skip all rules, or '# nolint: rule_name' to skip specific rules",
        ))
    } else {
        Ok(Some(Directive::Lint(LintDirective::SkipRules(rules))))
    }
}

#[cfg(test)]
mod test {
    use crate::Directive;
    use crate::LintDirective;
    use crate::parse_comment_directive;

    #[test]
    fn test_lint_directive() {
        let lint_skip = Ok(Some(Directive::Lint(LintDirective::Skip)));

        // "# nolint" without colon should skip all (must have space after #)
        assert_eq!(parse_comment_directive("# nolint"), lint_skip);

        // Without space after # should not work
        assert_eq!(parse_comment_directive("#nolint"), Ok(None));
        assert_eq!(parse_comment_directive("##nolint"), Ok(None));
        assert_eq!(parse_comment_directive("## nolint"), Ok(None));

        // "# nolint:" with empty rules should error (must have space after #)
        assert!(parse_comment_directive("# nolint:").is_err());
        assert_eq!(parse_comment_directive("#nolint:"), Ok(None)); // No space, not a directive
        assert!(parse_comment_directive("# nolint: ").is_err());

        // Skip specific rules
        let result = parse_comment_directive("# nolint: any_is_na");
        assert!(matches!(
            result,
            Ok(Some(Directive::Lint(LintDirective::SkipRules(ref rules)))) if rules == &vec!["any_is_na"]
        ));

        let result = parse_comment_directive("# nolint: any_is_na, coalesce");
        assert!(matches!(
            result,
            Ok(Some(Directive::Lint(LintDirective::SkipRules(ref rules))))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // lintr compatibility: also accept rule names that end with "_linter"
        let result = parse_comment_directive("# nolint: any_is_na_linter");
        assert!(matches!(
            result,
            Ok(Some(Directive::Lint(LintDirective::SkipRules(ref rules)))) if rules == &vec!["any_is_na"]
        ));

        let result = parse_comment_directive("# nolint: any_is_na_linter, coalesce_linter");
        assert!(matches!(
            result,
            Ok(Some(Directive::Lint(LintDirective::SkipRules(ref rules))))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // With extra spaces
        let result = parse_comment_directive("# nolint:  any_is_na  ,  coalesce_linter  ");
        assert!(matches!(
            result,
            Ok(Some(Directive::Lint(LintDirective::SkipRules(ref rules))))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // Can't have unrelated leading text
        assert_eq!(parse_comment_directive("# please nolint:"), Ok(None));
        assert_eq!(parse_comment_directive("# please nolint"), Ok(None));

        // Can't have text after nolint without a colon
        assert_eq!(parse_comment_directive("# nolint any_is_na"), Ok(None));
    }
}
