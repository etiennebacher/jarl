#[derive(Debug, PartialEq)]
pub enum Directive {
    Format(FormatDirective),
    Lint(LintDirective),
}

#[derive(Debug, PartialEq)]
pub enum FormatDirective {
    Skip,
    SkipFile,
}

#[derive(Debug, PartialEq)]
pub enum LintDirective {
    /// Skip all lints for the next node
    Skip,
    /// Skip specific lints for the next node, e.g. "# flir-skip: any_is_na, coalesce"
    SkipRules(Vec<String>),
}

/// Parse a comment directive
///
/// These take the form:
///
/// ```text
/// # <category>: <command> <optional-argument>
/// ```
///
/// Such as:
///
/// ```text
/// # fmt: skip
/// # fmt: skip file
/// # fmt: tabular
/// # fmt: align-right
/// # lint: skip
/// # lint: skip rule
/// ```
///
/// Note that directives are applied to the node they are attached to.
///
/// `text` should be single line but we don't check for this. A potential usage
/// of this function is to iterate over a document line by line to scan for a
/// directive.
pub fn parse_comment_directive(text: &str) -> Option<Directive> {
    let text = trim_comment(text)?;

    let (category, text) = text.split_once(':')?;
    let text = text.trim();

    match category {
        "fmt" => parse_format_directive(text),
        "flir-skip" => parse_lint_directive(text),
        _ => None,
    }
}

// This returns `None` if `text` is not a comment
fn trim_comment(text: &str) -> Option<&str> {
    let text = text.strip_prefix('#')?;
    let text = text.trim_start_matches('#');
    let text = text.trim_start();
    Some(text)
}

#[inline]
fn parse_format_directive(text: &str) -> Option<Directive> {
    match text {
        "skip" => Some(Directive::Format(FormatDirective::Skip)),
        "skip file" => Some(Directive::Format(FormatDirective::SkipFile)),
        _ => None,
    }
}

// https://github.com/posit-dev/air/issues/219
// Should be called only on the first line in a block of comments.
pub fn parse_special_skip_file(text: &str) -> Option<Directive> {
    let text = trim_comment(text)?;

    // Convention used in the R community (Roxygen, Rcpp, etc)
    if text.starts_with("Generated by") {
        return Some(Directive::Format(FormatDirective::SkipFile));
    }

    None
}

#[inline]
fn parse_lint_directive(text: &str) -> Option<Directive> {
    if text.is_empty() {
        // "# flir-skip:" with no rules means skip all
        return Some(Directive::Lint(LintDirective::Skip));
    }

    // Parse comma-separated rule names, e.g. "any_is_na, coalesce"
    let rules: Vec<String> = text
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    if rules.is_empty() {
        Some(Directive::Lint(LintDirective::Skip))
    } else {
        Some(Directive::Lint(LintDirective::SkipRules(rules)))
    }
}

#[cfg(test)]
mod test {
    use crate::parse_comment_directive;
    use crate::parse_special_skip_file;
    use crate::Directive;

    #[test]
    fn test_format_directive() {
        let format_skip = Some(Directive::Format(crate::FormatDirective::Skip));
        let format_skip_file = Some(Directive::Format(crate::FormatDirective::SkipFile));

        // Must have leading `#`
        assert!(parse_comment_directive("fmt: skip").is_none());

        // Must have `:`
        assert!(parse_comment_directive("# fmt skip").is_none());

        // `:` must be right after `fmt`
        assert!(parse_comment_directive("# fmt : skip").is_none());

        // Can't have extra spaces between `skip file`
        assert!(parse_comment_directive("# fmt: skip  file").is_none());

        // Can't have unrelated leading text
        assert!(parse_comment_directive("# please fmt: skip").is_none());

        // Can't have unrelated trailing text
        assert!(parse_comment_directive("# fmt: skip please").is_none());
        assert!(parse_comment_directive("# fmt: skip file please").is_none());

        assert_eq!(parse_comment_directive("# fmt: skip"), format_skip);
        assert_eq!(parse_comment_directive("#fmt:skip"), format_skip);
        assert_eq!(parse_comment_directive("#  fmt:  skip  "), format_skip);

        // Can have multiple `#`
        assert_eq!(parse_comment_directive("## fmt: skip"), format_skip);

        assert_eq!(
            parse_comment_directive("# fmt: skip file"),
            format_skip_file
        );
        assert_eq!(parse_comment_directive("#fmt:skip file"), format_skip_file);
        assert_eq!(
            parse_comment_directive("#  fmt:  skip file"),
            format_skip_file
        );

        assert!(parse_comment_directive("# Generated by:").is_none());
        assert_eq!(parse_special_skip_file("# Generated by:"), format_skip_file);
    }

    #[test]
    fn test_lint_directive() {
        use crate::LintDirective;

        let lint_skip = Some(Directive::Lint(LintDirective::Skip));

        // Basic skip all
        assert_eq!(parse_comment_directive("# flir-skip:"), lint_skip);
        assert_eq!(parse_comment_directive("#flir-skip:"), lint_skip);
        assert_eq!(parse_comment_directive("# flir-skip: "), lint_skip);

        // Skip specific rules
        let result = parse_comment_directive("# flir-skip: any_is_na");
        assert!(matches!(
            result,
            Some(Directive::Lint(LintDirective::SkipRules(ref rules))) if rules == &vec!["any_is_na"]
        ));

        let result = parse_comment_directive("# flir-skip: any_is_na, coalesce");
        assert!(matches!(
            result,
            Some(Directive::Lint(LintDirective::SkipRules(ref rules)))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // With extra spaces
        let result = parse_comment_directive("# flir-skip:  any_is_na  ,  coalesce  ");
        assert!(matches!(
            result,
            Some(Directive::Lint(LintDirective::SkipRules(ref rules)))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // Must have `:`
        assert!(parse_comment_directive("# flir-skip").is_none());

        // Can't have unrelated leading text
        assert!(parse_comment_directive("# please flir-skip:").is_none());
    }
}
