# Development Guide

This document provides guidance for developing and contributing to Flir, an R linter built in Rust.

## Project Architecture

Flir is organized as a Rust workspace with three main crates:

- **flir-core**: Core linting engine with rules, diagnostics, and fix logic
- **flir-cli**: Command-line interface for batch linting and fixing
- **flir-lsp**: Language Server Protocol implementation for editor integration

## Basic Structure

### Workspace Layout

```
flir2/
├── crates/
│   ├── flir-core/        # Core linting functionality
│   ├── flir-cli/         # CLI application
│   └── flir-lsp/         # LSP server
├── docs/                 # Documentation
├── demos/                # Example R files
└── Cargo.toml           # Workspace configuration
```

### flir-core Structure

The core crate contains:
- `src/analyze/`: AST traversal and rule application
- `src/lints/`: Individual lint rule implementations
- `src/config.rs`: Configuration management
- `src/diagnostic.rs`: Diagnostic message handling
- `src/fix.rs`: Code fix application
- `src/settings.rs`: Runtime settings


### List of existing rules

`flir-core/src/lints/mod.rs` contains the existing list of rules. Each rule must have a name, belong to one or several categories (`PERF`, `READ`, etc.), a `FixStatus` indicating whether it has a fix and if so whether this fix is safe or unsafe, and an optional minimum R version below which it is disabled.

### Lint definition

`flir-core/src/lints/` contains the definition of the rules, along with their associated documentation and tests. It has one subfolder per rule and two mandatory files: `<rule_name>.rs` (which contains the definition and documentation) and `mod.rs` (which contains the tests).

If there are snapshot tests for this rule, then a subfolder `snapshots` will also be created.

```
flir-core/src/lints/any_duplicated/
├── any_duplicated.rs
├── mod.rs
└── snapshots
    └── flir__lints__any_duplicated__tests__fix_output.snap
```

### AST Analysis

Flir uses the `air_r_parser` crate to parse R code into an Abstract Syntax Tree (AST). The core analysis happens in `flir-core/src/analyze/`, which contains modules for different AST node types:

- `expression.rs`: Analyzes R expressions
- `binary_expression.rs`: Handles binary operations like `==`, `+`, etc.
- `function_call.rs`: Analyzes function calls
- And more specific analyzers for different R constructs

Each analyzer applies relevant rules to specific AST node types. For example, the `equals_na` rule runs in `binary_expression.rs` because it detects patterns like `x == NA`.

### Configuration System

Settings are managed through:
- `config.rs`: Configuration file parsing (TOML format)
- `settings.rs`: Runtime settings and rule selection
- `rule_table.rs`: Tracks which rules are enabled/disabled

Configuration files are discovered hierarchically:
1. `flir.toml` in current directory
2. `pyproject.toml` [tool.flir] section
3. Parent directories (recursive search)
4. Default settings

### Diagnostic Pipeline

1. **AST Traversal**: Walk through R code AST nodes
2. **Rule Application**: Apply enabled rules to matching node types
3. **Diagnostic Generation**: Create structured diagnostic messages with locations
4. **Fix Generation**: Generate optional code fixes for violations
5. **Output**: Format diagnostics for display or apply fixes

## Integration tests

In addition to tests specific to each lint, some integration tests are stored in `tests/integration`. They are here to check that the general behavior is correct (what happens when there are no R files, no lints, several lints in the same file, a mix of safe and unsafe lints, etc.).

## Adding a new rule

This requires four main steps:

1. Add the new rule to the list in `flir-core/src/lints/mod.rs`. In the same file, also add `pub(crate) mod <rulename>;`
2. Add a subfolder with the rule name in `flir-core/src/lints`. Add the documentation and the code for the rule.
3. Add tests in `flir-core/src/lints/<rulename>/mod.rs`
4. Add the rule in the `flir-core/src/analyze` folder. This depends on the initial node in the AST. For instance, for the rule `"equals_na"`, we check the presence of code such as `x == NA`. Since the top node for this expression is a `R_BINARY_EXPRESSION`, this rule is ran in `flir-core/src/analyze/binary_expression.rs`.

See below some useful commands for the development.

## Useful commands

### CLI Development
* `cargo run --bin flir -- demos/foo.R` (or any other paths to check). The `--` in the middle is required to use the CLI in development mode (i.e. without installing it)
* `cargo run --bin flir -- --help` to see all available CLI options
* `cargo run --bin flir -- --fix demos/foo.R` to test fix mode

### LSP Development
* `cargo run --bin flir-lsp` to start the LSP server
* Configure your editor to use the built LSP server for R files

### General Development
* `cargo build && cargo test` - It is required to build the crate before running tests
* `cargo insta test` and `cargo insta review` (if necessary) since snapshot tests are used for the fixing mode
* `cargo install --path crates/flir-cli --profile=release` (or `--profile=dev`) to have a system-wide install and test the crate in other R projects
* `cargo clippy` - Run the linter on the Rust code
* `cargo fmt` - Format the Rust code

### Testing Specific Components
* `cargo test -p flir-core` - Test only the core crate
* `cargo test -p flir-cli` - Test only the CLI crate
* `cargo test -p flir-lsp` - Test only the LSP crate
* `cargo test --test integration` - Run integration tests

### Documentation
* `quarto render docs/` - Build the Quarto documentation
* `cargo doc --open` - Generate and view Rust API documentation

## Development Tips

### Rule Development
- Start with test cases before implementing the rule logic
- Use `insta` for snapshot testing of fixes
- Test both positive and negative cases
- Consider edge cases and different R syntax variations

### Performance Considerations
- Rules are applied in parallel across files
- Minimize allocations in hot paths
- Use AST pattern matching efficiently
- Profile with `cargo bench` if available

### Debugging
- Use `tracing` crate for structured logging
- Set `RUST_LOG=debug` for verbose output
- LSP server logs can help debug editor integration issues
